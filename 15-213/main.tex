\documentclass[10pt,fontset=windows]{article}
\usepackage{ctex}
\usepackage{amsthm,amsmath,amssymb} % math packages
\usepackage[hidelinks]{hyperref} % hide ref in table of contents
\usepackage{pifont} % \ding{73} makes a beautiful star
\usepackage{fontspec}
\usepackage{color}
\usepackage{geometry}
\definecolor{shadecolor}{rgb}{0.92,0.92,0.92}
\usepackage{framed}

\setcounter{tocdepth}{2}

\geometry{a4paper,scale=0.76}
\usepackage{enumerate}
\usepackage{enumitem}
\def\ttt#1{\texttt{#1}}
\setlist[enumerate,1]{label=(\arabic*).}
\setlist[enumerate,2]{label=(\alph*).}

\title{Notes on \texttt{15-213}}
\author{Jingze Xing}

\begin{document}
\maketitle
\tableofcontents
\newpage
\section{Bits, Bytes, and Integers}
\subsection{Integer representation: two's complement}
补码等价于原数在 $\bmod\ 2^w$ 意义下的无符号二进制表示
$$Byte2Signed(X)=-x_{w-1}\cdot 2^{w-1}+\sum_{i=0}^{w-2}x_i2^{i}$$
\indent 在 C 中，\ttt{signed}转化为\ttt{unsigned}类型时不改变其\ttt{bit pattern}，但是改变了解释的方式；包含\ttt{unsigned}类型的运算会将\ttt{signed}自动转换为\ttt{unsigned}类型。
$$x'=Unsigned2Signed(x)=x_{w-1}\cdot 2^w+x$$
\subsection{Integer arithmetics}
补码的特殊性质使得 $\underbrace{x_{w-1}\dots x_{w-1}}\limits_{k\ copies}x_{w-1}x_{w-2}\dots x_0=x_{w-1}x_{w-2}\dots x_0$，即通过\textbf{符号扩展（用符号位补足最高位）}来扩展字长，能够保持数值不变。\\
\indent 在对\ttt{signed}进行右移操作时，同样使用符号位补充，例如$-6=\underline{101}0\rightarrow {\color{red}1}\underline{101}=-3$。\\
\indent 无符号整数加法溢出时，计算得到 $s=x+y-2^w$；发生溢出当且仅当 $s<x$（或者等价的 $s<y$）。\\
\indent 符号整数乘法的结果的后 $w$ 位与有符号整数乘法的结果相同，因为 $x'\equiv x+2^w\equiv x\pmod{2^w}$。整数乘法不发生溢出的充要条件是 \ttt{x == 0 || (x * y) / x == y}。
\subsection{Memory organization}
计算机硬件模拟了一个足够长的0/1序列，每八个组成一个\textbf{字节(Byte)}，Byte是最小的可寻址单元，内存中的变量可能占据多个字节，约定其地址为其首个Byte的地址。\\
\indent 大端法：\textbf{最高}有效位放在\textbf{最小}地址处；小端法：\textbf{最低}有效位放在\textbf{最小}地址处。
\section{Floating point}

\end{document}